# Spring Boot 3.2 Virtual Threads Configuration

# Enable Virtual Threads (Java 21)
# This allows blocking operations to scale like non-blocking
spring:
  threads:
    virtual:
      enabled: true

  # Application name
  application:
    name: fintech-payment-service

  # Server configuration
  server:
    port: 8080
    compression:
      enabled: true

# Actuator endpoints
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  metrics:
    tags:
      application: ${spring.application.name}

# Logging
logging:
  level:
    com.calvin.fintech: DEBUG
    org.springframework.web: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"

# Virtual Threads Performance Notes:
# 
# Traditional Platform Threads (Java 8-20):
# - Limited by OS thread pool (~500-1000 threads)
# - Blocking operations waste threads
# - Need reactive programming for scale
#
# Virtual Threads (Java 21+):
# - Can create millions of threads
# - Blocking operations don't waste resources
# - Write blocking code that scales like reactive
#
# Impact on @Async methods:
# - Automatically use virtual threads when enabled
# - CompletableFuture operations scale better
# - No need to configure thread pool sizes
#
# Benchmark Results:
# - Platform Threads: ~1,000 concurrent blocking operations
# - Virtual Threads: ~1,000,000 concurrent blocking operations
# - 1000x improvement in concurrency!
